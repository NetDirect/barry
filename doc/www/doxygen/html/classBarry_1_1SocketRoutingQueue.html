<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Barry: Barry::SocketRoutingQueue Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceBarry.html">Barry</a>::<a class="el" href="classBarry_1_1SocketRoutingQueue.html">SocketRoutingQueue</a></div>
<h1>Barry::SocketRoutingQueue Class Reference</h1><!-- doxytag: class="Barry::SocketRoutingQueue" --><a href="classBarry_1_1SocketRoutingQueue-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>

<p>

<p>
Definition at line <a class="el" href="router_8h-source.html#l00039">39</a> of file <a class="el" href="router_8h-source.html">router.h</a>.<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e990426361a54d75b9bf734471c7819f"></a><!-- doxytag: member="Barry::SocketRoutingQueue::SocketDataHandler" ref="e990426361a54d75b9bf734471c7819f" args="(void *ctx, Data *)" -->
typedef void(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1SocketRoutingQueue.html#e990426361a54d75b9bf734471c7819f">SocketDataHandler</a> (void *ctx, <a class="el" href="classBarry_1_1Data.html">Data</a> *)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c5d82ee295c53c1e44e1ebd005550208"></a><!-- doxytag: member="Barry::SocketRoutingQueue::QueueEntryPtr" ref="c5d82ee295c53c1e44e1ebd005550208" args="" -->
typedef std::tr1::shared_ptr&lt;<br>
 <a class="el" href="structBarry_1_1SocketRoutingQueue_1_1QueueEntry.html">QueueEntry</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1SocketRoutingQueue.html#c5d82ee295c53c1e44e1ebd005550208">QueueEntryPtr</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ca0e6e43f729dbc1380a56bfed9e18f5"></a><!-- doxytag: member="Barry::SocketRoutingQueue::SocketId" ref="ca0e6e43f729dbc1380a56bfed9e18f5" args="" -->
typedef uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1SocketRoutingQueue.html#ca0e6e43f729dbc1380a56bfed9e18f5">SocketId</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="64abf6e78911eae2ead4d5aee3363676"></a><!-- doxytag: member="Barry::SocketRoutingQueue::SocketQueueMap" ref="64abf6e78911eae2ead4d5aee3363676" args="" -->
typedef std::map&lt; <a class="el" href="classBarry_1_1SocketRoutingQueue.html#ca0e6e43f729dbc1380a56bfed9e18f5">SocketId</a>,<br>
 <a class="el" href="classBarry_1_1SocketRoutingQueue.html#c5d82ee295c53c1e44e1ebd005550208">QueueEntryPtr</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1SocketRoutingQueue.html#64abf6e78911eae2ead4d5aee3363676">SocketQueueMap</a></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d1132ee4d1ca1608ac25ae779bb6f3ee"></a><!-- doxytag: member="Barry::SocketRoutingQueue::SocketRoutingQueue" ref="d1132ee4d1ca1608ac25ae779bb6f3ee" args="(int prealloc_buffer_count=4)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1SocketRoutingQueue.html#d1132ee4d1ca1608ac25ae779bb6f3ee">SocketRoutingQueue</a> (int prealloc_buffer_count=4)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="86b6e10d716209f1653e8deb4c268da7"></a><!-- doxytag: member="Barry::SocketRoutingQueue::~SocketRoutingQueue" ref="86b6e10d716209f1653e8deb4c268da7" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1SocketRoutingQueue.html#86b6e10d716209f1653e8deb4c268da7">~SocketRoutingQueue</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9cbc37bb2363bc99d179b78c20b66af5"></a><!-- doxytag: member="Barry::SocketRoutingQueue::SetUsbDevice" ref="9cbc37bb2363bc99d179b78c20b66af5" args="(Usb::Device *dev, int writeEp, int readEp)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1SocketRoutingQueue.html#9cbc37bb2363bc99d179b78c20b66af5">SetUsbDevice</a> (<a class="el" href="classUsb_1_1Device.html">Usb::Device</a> *dev, int writeEp, int readEp)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b7b24307536d23dc7fbdfc9980b0df40"></a><!-- doxytag: member="Barry::SocketRoutingQueue::ClearUsbDevice" ref="b7b24307536d23dc7fbdfc9980b0df40" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1SocketRoutingQueue.html#b7b24307536d23dc7fbdfc9980b0df40">ClearUsbDevice</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="04bca9aa659c3f7113b9d37573d3641e"></a><!-- doxytag: member="Barry::SocketRoutingQueue::UsbDeviceReady" ref="04bca9aa659c3f7113b9d37573d3641e" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1SocketRoutingQueue.html#04bca9aa659c3f7113b9d37573d3641e">UsbDeviceReady</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4b9c0971017610349bef8e31d78cf493"></a><!-- doxytag: member="Barry::SocketRoutingQueue::GetUsbDevice" ref="4b9c0971017610349bef8e31d78cf493" args="()" -->
<a class="el" href="classUsb_1_1Device.html">Usb::Device</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1SocketRoutingQueue.html#4b9c0971017610349bef8e31d78cf493">GetUsbDevice</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1SocketRoutingQueue.html#6b4f7e9653512bb6ad91d05894248517">AllocateBuffers</a> (int count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class starts out with no buffers, and will grow one buffer at a time if needed.  <a href="#6b4f7e9653512bb6ad91d05894248517"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1SocketRoutingQueue.html#dc15a0034c1dac424cf8a5dc32f12595">DefaultRead</a> (<a class="el" href="classBarry_1_1Data.html">Data</a> &amp;receive, int timeout=-1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the data for the next unregistered socket.  <a href="#dc15a0034c1dac424cf8a5dc32f12595"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classBarry_1_1DataHandle.html">DataHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1SocketRoutingQueue.html#e9fac0a9073c44567987230843712e94">DefaultRead</a> (int timeout=-1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This version does not perform a copy.  <a href="#e9fac0a9073c44567987230843712e94"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1SocketRoutingQueue.html#5ef298211c09178f25bd043eca283ccb">RegisterInterest</a> (<a class="el" href="classBarry_1_1SocketRoutingQueue.html#ca0e6e43f729dbc1380a56bfed9e18f5">SocketId</a> socket, <a class="el" href="classBarry_1_1SocketRoutingQueue.html#e990426361a54d75b9bf734471c7819f">SocketDataHandler</a> handler=0, void *context=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register an interest in data from a certain socket.  <a href="#5ef298211c09178f25bd043eca283ccb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1SocketRoutingQueue.html#aa0f088f013150bc45ca47fabede9731">UnregisterInterest</a> (<a class="el" href="classBarry_1_1SocketRoutingQueue.html#ca0e6e43f729dbc1380a56bfed9e18f5">SocketId</a> socket)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unregisters interest in data from the given socket, and discards any existing data in its interest queue.  <a href="#aa0f088f013150bc45ca47fabede9731"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1SocketRoutingQueue.html#58298b4598a0166720b745198cb99fe6">SocketRead</a> (<a class="el" href="classBarry_1_1SocketRoutingQueue.html#ca0e6e43f729dbc1380a56bfed9e18f5">SocketId</a> socket, <a class="el" href="classBarry_1_1Data.html">Data</a> &amp;receive, int timeout=-1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads data from the interested socket cache.  <a href="#58298b4598a0166720b745198cb99fe6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classBarry_1_1DataHandle.html">DataHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1SocketRoutingQueue.html#cbe8506c04cb6ff9942766a3ba39cbd4">SocketRead</a> (<a class="el" href="classBarry_1_1SocketRoutingQueue.html#ca0e6e43f729dbc1380a56bfed9e18f5">SocketId</a> socket, int timeout=-1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copying is not performed with this function.  <a href="#cbe8506c04cb6ff9942766a3ba39cbd4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="127eb5705d3be2aa3c7f462c40851cb6"></a><!-- doxytag: member="Barry::SocketRoutingQueue::IsAvailable" ref="127eb5705d3be2aa3c7f462c40851cb6" args="(SocketId socket) const" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1SocketRoutingQueue.html#127eb5705d3be2aa3c7f462c40851cb6">IsAvailable</a> (<a class="el" href="classBarry_1_1SocketRoutingQueue.html#ca0e6e43f729dbc1380a56bfed9e18f5">SocketId</a> socket) const</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1SocketRoutingQueue.html#a66c053840c931e3c6f1ed2293bd3736">DoRead</a> (std::string &amp;msg, int timeout=-1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called by the application's "read thread" to read the next usb packet and route it to the correct queue.  <a href="#a66c053840c931e3c6f1ed2293bd3736"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0928d093a19158b777858182c3ff9963"></a><!-- doxytag: member="Barry::SocketRoutingQueue::SpinoffSimpleReadThread" ref="0928d093a19158b777858182c3ff9963" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1SocketRoutingQueue.html#0928d093a19158b777858182c3ff9963">SpinoffSimpleReadThread</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1SocketRoutingQueue.html#a496dddb546fc96f337cf885dfdf219c">ReturnBuffer</a> (<a class="el" href="classBarry_1_1Data.html">Data</a> *buf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides a method of returning a buffer to the free queue after processing.  <a href="#a496dddb546fc96f337cf885dfdf219c"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1SocketRoutingQueue.html#43c1fc957e2da415290e86bc6e66aa25">SimpleReadThread</a> (void *userptr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience thread to handle USB read activity.  <a href="#43c1fc957e2da415290e86bc6e66aa25"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="61abc622ba8666fb48d9ad9e2704496f"></a><!-- doxytag: member="Barry::SocketRoutingQueue::DataHandle" ref="61abc622ba8666fb48d9ad9e2704496f" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1SocketRoutingQueue.html#61abc622ba8666fb48d9ad9e2704496f">DataHandle</a></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBarry_1_1SocketRoutingQueue_1_1QueueEntry.html">QueueEntry</a></td></tr>

</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a496dddb546fc96f337cf885dfdf219c"></a><!-- doxytag: member="Barry::SocketRoutingQueue::ReturnBuffer" ref="a496dddb546fc96f337cf885dfdf219c" args="(Data *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Barry::SocketRoutingQueue::ReturnBuffer           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBarry_1_1Data.html">Data</a> *&nbsp;</td>
          <td class="paramname"> <em>buf</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Provides a method of returning a buffer to the free queue after processing. 
<p>
The <a class="el" href="classBarry_1_1DataHandle.html">DataHandle</a> class calls this automatically from its destructor. 
<p>
Definition at line <a class="el" href="router_8cc-source.html#l00069">69</a> of file <a class="el" href="router_8cc-source.html">router.cc</a>.
<p>
References <a class="el" href="dataqueue_8cc-source.html#l00060">Barry::DataQueue::push()</a>.
</div>
</div><p>
<a class="anchor" name="43c1fc957e2da415290e86bc6e66aa25"></a><!-- doxytag: member="Barry::SocketRoutingQueue::SimpleReadThread" ref="43c1fc957e2da415290e86bc6e66aa25" args="(void *userptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * Barry::SocketRoutingQueue::SimpleReadThread           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userptr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience thread to handle USB read activity. 
<p>

<p>
Definition at line <a class="el" href="router_8cc-source.html#l00080">80</a> of file <a class="el" href="router_8cc-source.html">router.cc</a>.
<p>
References <a class="el" href="router_8cc-source.html#l00336">DoRead()</a>, and <a class="el" href="router_8h-source.html#l00080">m_continue_reading</a>.
<p>
Referenced by <a class="el" href="router_8cc-source.html#l00446">SpinoffSimpleReadThread()</a>.
</div>
</div><p>
<a class="anchor" name="6b4f7e9653512bb6ad91d05894248517"></a><!-- doxytag: member="Barry::SocketRoutingQueue::AllocateBuffers" ref="6b4f7e9653512bb6ad91d05894248517" args="(int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Barry::SocketRoutingQueue::AllocateBuffers           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This class starts out with no buffers, and will grow one buffer at a time if needed. 
<p>
Call this to allocate count buffers all at once and place them on the free queue. After calling this function, at least count buffers will exist in the free queue. If there are already count buffers, none will be added. 
<p>
Definition at line <a class="el" href="router_8cc-source.html#l00136">136</a> of file <a class="el" href="router_8cc-source.html">router.cc</a>.
<p>
References <a class="el" href="dataqueue_8cc-source.html#l00060">Barry::DataQueue::push()</a>, and <a class="el" href="dataqueue_8cc-source.html#l00212">Barry::DataQueue::size()</a>.
<p>
Referenced by <a class="el" href="router_8cc-source.html#l00036">SocketRoutingQueue()</a>.
</div>
</div><p>
<a class="anchor" name="dc15a0034c1dac424cf8a5dc32f12595"></a><!-- doxytag: member="Barry::SocketRoutingQueue::DefaultRead" ref="dc15a0034c1dac424cf8a5dc32f12595" args="(Data &amp;receive, int timeout=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Barry::SocketRoutingQueue::DefaultRead           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBarry_1_1Data.html">Data</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>receive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the data for the next unregistered socket. 
<p>
Blocks until timeout or data is available. Returns false (or null pointer) on timeout and no data. With the return version of the function, there is no copying performed.<p>
This version performs a copy. 
<p>
Definition at line <a class="el" href="router_8cc-source.html#l00157">157</a> of file <a class="el" href="router_8cc-source.html">router.cc</a>.
<p>
References <a class="el" href="router_8h-source.html#l00214">Barry::DataHandle::get()</a>.
</div>
</div><p>
<a class="anchor" name="e9fac0a9073c44567987230843712e94"></a><!-- doxytag: member="Barry::SocketRoutingQueue::DefaultRead" ref="e9fac0a9073c44567987230843712e94" args="(int timeout=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBarry_1_1DataHandle.html">DataHandle</a> Barry::SocketRoutingQueue::DefaultRead           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>-1</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This version does not perform a copy. 
<p>

<p>
Definition at line <a class="el" href="router_8cc-source.html#l00171">171</a> of file <a class="el" href="router_8cc-source.html">router.cc</a>.
<p>
References <a class="el" href="router_8h-source.html#l00041">DataHandle</a>, and <a class="el" href="dataqueue_8cc-source.html#l00109">Barry::DataQueue::wait_pop()</a>.
</div>
</div><p>
<a class="anchor" name="5ef298211c09178f25bd043eca283ccb"></a><!-- doxytag: member="Barry::SocketRoutingQueue::RegisterInterest" ref="5ef298211c09178f25bd043eca283ccb" args="(SocketId socket, SocketDataHandler handler=0, void *context=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Barry::SocketRoutingQueue::RegisterInterest           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBarry_1_1SocketRoutingQueue.html#ca0e6e43f729dbc1380a56bfed9e18f5">SocketId</a>&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBarry_1_1SocketRoutingQueue.html#e990426361a54d75b9bf734471c7819f">SocketDataHandler</a>&nbsp;</td>
          <td class="paramname"> <em>handler</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>context</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register an interest in data from a certain socket. 
<p>
To read from that socket, use the <a class="el" href="classBarry_1_1SocketRoutingQueue.html#58298b4598a0166720b745198cb99fe6">SocketRead()</a> function from then on.<p>
Any non-registered socket goes in the default queue and must be read by <a class="el" href="classBarry_1_1SocketRoutingQueue.html#dc15a0034c1dac424cf8a5dc32f12595">DefaultRead()</a><p>
If not null, handler is called when new data is read. It will be called in the same thread instance that <a class="el" href="classBarry_1_1SocketRoutingQueue.html#a66c053840c931e3c6f1ed2293bd3736">DoRead()</a> is called from. Handler is passed the <a class="el" href="classBarry_1_1DataQueue.html">DataQueue</a> <a class="el" href="classBarry_1_1Data.html">Data</a> pointer, and so no copying is done. Once the handler returns, the data is considered processed and not added to the interested queue, but instead returned to m_free.<p>
Throws std::logic_error if already registered. 
<p>
Definition at line <a class="el" href="router_8cc-source.html#l00196">196</a> of file <a class="el" href="router_8cc-source.html">router.cc</a>.
<p>
Referenced by <a class="el" href="socket_8cc-source.html#l00830">Barry::Socket::RegisterInterest()</a>.
</div>
</div><p>
<a class="anchor" name="aa0f088f013150bc45ca47fabede9731"></a><!-- doxytag: member="Barry::SocketRoutingQueue::UnregisterInterest" ref="aa0f088f013150bc45ca47fabede9731" args="(SocketId socket)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Barry::SocketRoutingQueue::UnregisterInterest           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBarry_1_1SocketRoutingQueue.html#ca0e6e43f729dbc1380a56bfed9e18f5">SocketId</a>&nbsp;</td>
          <td class="paramname"> <em>socket</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unregisters interest in data from the given socket, and discards any existing data in its interest queue. 
<p>
Any new incoming data for this socket will be placed in the default queue. 
<p>
Definition at line <a class="el" href="router_8cc-source.html#l00218">218</a> of file <a class="el" href="router_8cc-source.html">router.cc</a>.
<p>
References <a class="el" href="dataqueue_8cc-source.html#l00182">Barry::DataQueue::append_from()</a>.
<p>
Referenced by <a class="el" href="socket_8cc-source.html#l00843">Barry::Socket::UnregisterInterest()</a>.
</div>
</div><p>
<a class="anchor" name="58298b4598a0166720b745198cb99fe6"></a><!-- doxytag: member="Barry::SocketRoutingQueue::SocketRead" ref="58298b4598a0166720b745198cb99fe6" args="(SocketId socket, Data &amp;receive, int timeout=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Barry::SocketRoutingQueue::SocketRead           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBarry_1_1SocketRoutingQueue.html#ca0e6e43f729dbc1380a56bfed9e18f5">SocketId</a>&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBarry_1_1Data.html">Data</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>receive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads data from the interested socket cache. 
<p>
Can only read from sockets that have been previously registered.<p>
Blocks until timeout or data is available.<p>
Returns false (or null pointer) on timeout and no data. With the return version of the function, there is no copying performed.<p>
Throws std::logic_error if a socket was requested that was not previously registered.<p>
Copying is performed with this function. 
<p>
Definition at line <a class="el" href="router_8cc-source.html#l00254">254</a> of file <a class="el" href="router_8cc-source.html">router.cc</a>.
<p>
References <a class="el" href="router_8h-source.html#l00214">Barry::DataHandle::get()</a>.
<p>
Referenced by <a class="el" href="socket_8cc-source.html#l00663">Barry::Socket::Receive()</a>.
</div>
</div><p>
<a class="anchor" name="cbe8506c04cb6ff9942766a3ba39cbd4"></a><!-- doxytag: member="Barry::SocketRoutingQueue::SocketRead" ref="cbe8506c04cb6ff9942766a3ba39cbd4" args="(SocketId socket, int timeout=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBarry_1_1DataHandle.html">DataHandle</a> Barry::SocketRoutingQueue::SocketRead           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBarry_1_1SocketRoutingQueue.html#ca0e6e43f729dbc1380a56bfed9e18f5">SocketId</a>&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copying is not performed with this function. 
<p>
Throws std::logic_error if a socket was requested that was not previously registered. 
<p>
Definition at line <a class="el" href="router_8cc-source.html#l00271">271</a> of file <a class="el" href="router_8cc-source.html">router.cc</a>.
<p>
References <a class="el" href="router_8h-source.html#l00041">DataHandle</a>, <a class="el" href="dataqueue_8h-source.html#l00049">Barry::DataQueue::m_queue</a>, and <a class="el" href="dataqueue_8cc-source.html#l00109">Barry::DataQueue::wait_pop()</a>.
</div>
</div><p>
<a class="anchor" name="a66c053840c931e3c6f1ed2293bd3736"></a><!-- doxytag: member="Barry::SocketRoutingQueue::DoRead" ref="a66c053840c931e3c6f1ed2293bd3736" args="(std::string &amp;msg, int timeout=-1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Barry::SocketRoutingQueue::DoRead           </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called by the application's "read thread" to read the next usb packet and route it to the correct queue. 
<p>
Returns after every read, even if a handler is associated with a queue. Note: this function is safe to call before <a class="el" href="classBarry_1_1SocketRoutingQueue.html#9cbc37bb2363bc99d179b78c20b66af5">SetUsbDevice()</a> is called... it just doesn't do anything if there is no usb device to work with.<p>
Timeout is in milliseconds.<p>
Returns false in the case of USB errors and puts the error message in msg. 
<p>
Definition at line <a class="el" href="router_8cc-source.html#l00336">336</a> of file <a class="el" href="router_8cc-source.html">router.cc</a>.
<p>
References <a class="el" href="endian_8h-source.html#l00030">btohs</a>, <a class="el" href="usbwrap_8cc-source.html#l00201">Usb::Device::BulkRead()</a>, <a class="el" href="router_8h-source.html#l00041">DataHandle</a>, <a class="el" href="router_8h-source.html#l00214">Barry::DataHandle::get()</a>, <a class="el" href="data_8h-source.html#l00063">Barry::Data::GetSize()</a>, <a class="el" href="protostructs_8h-source.html#l00591">MAKE_PACKET</a>, <a class="el" href="dataqueue_8cc-source.html#l00087">Barry::DataQueue::pop()</a>, <a class="el" href="dataqueue_8cc-source.html#l00060">Barry::DataQueue::push()</a>, <a class="el" href="router_8h-source.html#l00219">Barry::DataHandle::release()</a>, and <a class="el" href="scoped__lock_8h-source.html#l00046">Barry::scoped_lock::unlock()</a>.
<p>
Referenced by <a class="el" href="router_8cc-source.html#l00080">SimpleReadThread()</a>.
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="router_8h-source.html">router.h</a><li><a class="el" href="router_8cc-source.html">router.cc</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Wed Sep 24 21:27:33 2008 for Barry by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
