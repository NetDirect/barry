<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Barry: Barry Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Barry Namespace Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Project namespace, containing all related functions and classes. 
<p>
This is the only namespace applications should be concerned with, for now. 
<p>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Backup</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1Builder.html">Builder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for the builder functor hierarchy.  <a href="classBarry_1_1Builder.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1DBDataBuilder.html">DBDataBuilder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper class around a <a class="el" href="classBarry_1_1DBData.html" title="Database record data class.">DBData</a> object, to make it easy to pass a <a class="el" href="classBarry_1_1DBData.html" title="Database record data class.">DBData</a> object into a function or API that requires a builder.  <a href="classBarry_1_1DBDataBuilder.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1RecordBuilder.html">RecordBuilder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Template class for easy creation of specific protocol packet builder objects.  <a href="classBarry_1_1RecordBuilder.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1RecordFetch.html">RecordFetch</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic record fetch class, to help with using records without builder classes.  <a href="classBarry_1_1RecordFetch.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1CodFileBuilder.html">CodFileBuilder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="classBarry_1_1CodFileBuilder.html" title="The CodFileBuilder class is used to assemble multiple .cod files into a single packed...">CodFileBuilder</a> class is used to assemble multiple .cod files into a single packed .cod file using the pkzip file format.  <a href="classBarry_1_1CodFileBuilder.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>ConfigFile</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>GlobalConfigFile</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Connector</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>DesktopConnector</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1Controller.html">Controller</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The main interface class.  <a href="classBarry_1_1Controller.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Data</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Diff</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1DBData.html">DBData</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Database record data class.  <a href="classBarry_1_1DBData.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1DataQueue.html">DataQueue</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class provides a thread aware fifo queue for Data objects, providing memory management for all Data object pointers it contains.  <a href="classBarry_1_1DataQueue.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1Error.html">Error</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The base class for any future derived exceptions.  <a href="classBarry_1_1Error.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1BadPassword.html">BadPassword</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A bad or unknown password when talking to the device.  <a href="classBarry_1_1BadPassword.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1PinNotFound.html">PinNotFound</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thrown by the Connector class when unable to find the requested Pin If the attached pin is not Valid(), then unable to autodetect device.  <a href="classBarry_1_1PinNotFound.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1BadData.html">BadData</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thrown by record classes if their data is invalid and cannot be uploaded to the Blackberry.  <a href="classBarry_1_1BadData.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1BadSize.html">BadSize</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unexpected packet size, or not enough data.  <a href="classBarry_1_1BadSize.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1ErrnoError.html">ErrnoError</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">System error that provides an errno error code.  <a href="classBarry_1_1ErrnoError.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1ConfigFileError.html">ConfigFileError</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thrown by the ConfigFile class when encountering a serious system error while loading the global config file for a given PIN.  <a href="classBarry_1_1ConfigFileError.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1BadPackedFormat.html">BadPackedFormat</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thrown by record classes that don't recognize a given packed format code.  <a href="classBarry_1_1BadPackedFormat.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1BadPacket.html">BadPacket</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thrown by the socket class if a packet command's response indicates an error.  <a href="classBarry_1_1BadPacket.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1ConvertError.html">ConvertError</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thrown by the vformat related barrysync library classes.  <a href="classBarry_1_1ConvertError.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1BackupError.html">BackupError</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thrown by the Backup parser class when there is a problem with the low level file operation.  <a href="classBarry_1_1BackupError.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1RestoreError.html">RestoreError</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thrown by the <a class="el" href="classBarry_1_1Restore.html" title="Barry Backup Restore builder class.">Restore</a> builder class when there is a problem with the low level file operation.  <a href="classBarry_1_1RestoreError.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1IConvHandle.html">IConvHandle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper class for a two-way iconv_t handle pair.  <a href="classBarry_1_1IConvHandle.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1IConverter.html">IConverter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Main charset conversion class, primarily focused on converting between the Blackberry charset and an application-specified one.  <a href="classBarry_1_1IConverter.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1ContactLdif.html">ContactLdif</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for generating LDIF output based on a <a class="el" href="classBarry_1_1Contact.html" title="Represents a single record in the Address Book Blackberry database.">Barry::Contact</a> record object.  <a href="classBarry_1_1ContactLdif.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1LdifStore.html">LdifStore</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Storage class suitable for use in a RecordParser&lt;&gt; or RecordBuilder&lt;&gt;.  <a href="classBarry_1_1LdifStore.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1LogLock.html">LogLock</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RAII locking class used to protect the logStream passed into <a class="el" href="namespaceBarry.html#2e28bd59aebe0bece5a46f02ef7dbd3d" title="Barry library initializer.">Barry::Init()</a> (<a class="el" href="common_8h.html" title="General header for the Barry library.">common.h</a>).  <a href="classBarry_1_1LogLock.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1DeviceBuilder.html">DeviceBuilder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Takes a list of database dbId's and behaves like a <a class="el" href="classBarry_1_1Builder.html" title="Base class for the builder functor hierarchy.">Builder</a>, trying to avoid copies where possible on the device loading end.  <a href="classBarry_1_1DeviceBuilder.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1DeviceParser.html">DeviceParser</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A parser class that "parses" raw data into a device.  <a href="classBarry_1_1DeviceParser.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>JLDirectory</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>JLDirectoryEntry</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>JLScreenInfo</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>JLEventlog</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>JLEventlogEntry</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>JLDeviceInfo</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>JVMModulesList</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>JVMModulesEntry</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>JVMThreadsList</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>JVMThreadsEntry</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>MimeBuilder</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Modem</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Packet</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1ZeroPacket.html">ZeroPacket</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides an API for building and analyzing socket-0 protocol packets.  <a href="classBarry_1_1ZeroPacket.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1DBPacket.html">DBPacket</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides an API for building and analyzing raw DB protocol packets.  <a href="classBarry_1_1DBPacket.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1JLPacket.html">JLPacket</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides an API for building and analyzing raw Javaloader protocol packets.  <a href="classBarry_1_1JLPacket.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1JVMPacket.html">JVMPacket</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides an API for building and analyzing raw JavaDebug protocol packets.  <a href="classBarry_1_1JVMPacket.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1Parser.html">Parser</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for the parser hierarchy.  <a href="classBarry_1_1Parser.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1NullParser.html">NullParser</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If in debug mode, this class can be used as a null parser.  <a href="classBarry_1_1NullParser.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1HexDumpParser.html">HexDumpParser</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dumps raw hex of the given <a class="el" href="classBarry_1_1DBData.html" title="Database record data class.">DBData</a> to the given stream.  <a href="classBarry_1_1HexDumpParser.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1RecordParserBase.html">RecordParserBase</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract base class for the following <a class="el" href="classBarry_1_1RecordParser.html" title="Template class for easy creation of specific parser objects.">RecordParser</a> template, that exposes some information on the specifics that the record parser can handle.  <a href="classBarry_1_1RecordParserBase.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1NullStore.html">NullStore</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A Storage class for RecordParser&lt;&gt; that does nothing, for the cases where you only want to dump parsed record data to a stream.  <a href="classBarry_1_1NullStore.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1DumpStore.html">DumpStore</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A Storage class for RecordParser&lt;&gt; that dumps the parsed record data to the given stream.  <a href="classBarry_1_1DumpStore.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1RecordParser.html">RecordParser</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Template class for easy creation of specific parser objects.  <a href="classBarry_1_1RecordParser.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1AllRecordStore.html">AllRecordStore</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class with overloaded functor behaviour for all available record classes.  <a href="classBarry_1_1AllRecordStore.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1MultiRecordParser.html">MultiRecordParser</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Container parser class that accepts multiple <a class="el" href="classBarry_1_1Parser.html" title="Base class for the parser hierarchy.">Parser</a> objects (often RecordParser&lt;&gt; objects but they don't have to be) and automatically routes incoming records to the appropriate parser.  <a href="classBarry_1_1MultiRecordParser.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1AllRecordDumpStore.html">AllRecordDumpStore</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Derived from <a class="el" href="classBarry_1_1AllRecordStore.html" title="Base class with overloaded functor behaviour for all available record classes.">AllRecordStore</a>, which just calls each record's Dump() member with the given stream.  <a href="classBarry_1_1AllRecordDumpStore.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1AllRecordParser.html">AllRecordParser</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience parser that creates a <a class="el" href="classBarry_1_1MultiRecordParser.html" title="Container parser class that accepts multiple Parser objects (often RecordParser&lt;&gt;...">MultiRecordParser</a> with all known record parsers added.  <a href="classBarry_1_1AllRecordParser.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1TeeParser.html">TeeParser</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends incoming <a class="el" href="classBarry_1_1DBData.html" title="Database record data class.">DBData</a> objects to all the parsers in its list.  <a href="classBarry_1_1TeeParser.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Pin</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1Pipe.html">Pipe</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads data from a builder and feeds it into a parser.  <a href="classBarry_1_1Pipe.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>PppFilter</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>ProbeResult</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Probe</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Bookmark</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Calendar</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>CalendarAll</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>CallLog</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>ContactGroupLink</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1Contact.html">Contact</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a single record in the Address Book Blackberry database.  <a href="classBarry_1_1Contact.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1ContentStore.html">ContentStore</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a single record in the Content Store Blackberry database.  <a href="classBarry_1_1ContentStore.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Folder</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Memo</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Message</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>MessageBase</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>PINMessage</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>RecurBase</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>SavedMessage</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>ServiceBookData</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>ServiceBookConfig</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>ServiceBook</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Sms</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Task</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Timezone</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>FieldLink</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Cr2LfWrapper</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>CommandTableCommand</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>CommandTable</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>RecordStateTableState</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>RecordStateTable</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>DatabaseItem</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>DatabaseDatabase</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>UnknownData</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>UnknownField</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>EmailAddress</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>PostalAddress</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>Date</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>CategoryList</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1Restore.html">Restore</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="namespaceBarry.html" title="Project namespace, containing all related functions and classes.">Barry</a> Backup <a class="el" href="classBarry_1_1Restore.html" title="Barry Backup Restore builder class.">Restore</a> builder class.  <a href="classBarry_1_1Restore.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>SocketRoutingQueue</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1DataHandle.html">DataHandle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">std::auto_ptr like class that handles pointers to Data, but instead of freeing them completely, the Data objects are turned to the SocketRoutingQueue from whence they came.  <a href="classBarry_1_1DataHandle.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>BoostLoader</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>BoostSaver</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1BoostParser.html">BoostParser</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This <a class="el" href="classBarry_1_1Parser.html" title="Base class for the parser hierarchy.">Parser</a> turns incoming records (which can be of any record type included in ALL_KNOWN_PARSER_TYPES) into a Boost Serialization stream on the given iostream.  <a href="classBarry_1_1BoostParser.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1BoostBuilder.html">BoostBuilder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This <a class="el" href="classBarry_1_1Builder.html" title="Base class for the builder functor hierarchy.">Builder</a> class reads a boost serialization stream, and converts them into <a class="el" href="classBarry_1_1DBData.html" title="Database record data class.">DBData</a> records.  <a href="classBarry_1_1BoostBuilder.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>scoped_lock</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>semaphore</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>SHA_CTX</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>SocketZero</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1Socket.html">Socket</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encapsulates a "logical socket" in the Blackberry USB protocol.  <a href="classBarry_1_1Socket.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>Thread</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>TimeZone</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1vSmartPtr.html">vSmartPtr</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A special smart pointer for variables that have their own special 'free' functions.  <a href="classBarry_1_1vSmartPtr.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1vLateSmartPtr.html">vLateSmartPtr</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Variation of the above smart pointer that allows the user to assign a free function after construction, in the case of dlopen()'d frees.  <a href="classBarry_1_1vLateSmartPtr.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BXEXPORT size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBarry.html#e9d92a617771de40f7bb5a15b8da1807">GetTotalBitmapSize</a> (const JLScreenInfo &amp;info)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the total number of bytes needed to convert a screenshot of the given dimensions into a bitmap, using the <a class="el" href="namespaceBarry.html#9da780aab46e04d16fddd855c85933ba" title="Converts screenshot data obtained via JavaLoader::GetScreenshot() into uncompressed...">ScreenshotToBitmap()</a> function.  <a href="#e9d92a617771de40f7bb5a15b8da1807"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BXEXPORT void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBarry.html#9da780aab46e04d16fddd855c85933ba">ScreenshotToBitmap</a> (const JLScreenInfo &amp;info, const Data &amp;screenshot, Data &amp;bitmap)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts screenshot data obtained via JavaLoader::GetScreenshot() into uncompressed bitmap format, suitable for writing BMP files.  <a href="#9da780aab46e04d16fddd855c85933ba"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class RecordT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceBarry.html#1694e381d8f7c0a41714992c831e716b">SetDBData</a> (const RecordT &amp;rec, <a class="el" href="classBarry_1_1DBData.html">DBData</a> &amp;data, size_t &amp;offset, const <a class="el" href="classBarry_1_1IConverter.html">IConverter</a> *ic)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contains the proper way to convert a record object into a <a class="el" href="classBarry_1_1DBData.html" title="Database record data class.">DBData</a> object.  <a href="#1694e381d8f7c0a41714992c831e716b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBarry.html#07808b7a4cabe1399d5432eb1ee1eabf">SeekNextCod</a> (std::istream &amp;input)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Seeks the input stream to the next packed sibling .cod file and returns the packed .cod file size.  <a href="#07808b7a4cabe1399d5432eb1ee1eabf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBarry.html#2e28bd59aebe0bece5a46f02ef7dbd3d">Init</a> (bool data_dump_mode, std::ostream *logStream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="namespaceBarry.html" title="Project namespace, containing all related functions and classes.">Barry</a> library initializer.  <a href="#2e28bd59aebe0bece5a46f02ef7dbd3d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBarry.html#59da38213acb8827d30bddfc54bbfe2a">Verbose</a> (bool data_dump_mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This API call lets the application enable / disable verbose debug output on the fly.  <a href="#59da38213acb8827d30bddfc54bbfe2a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBarry.html#ec655def4d700239e60ed3ccb417e0c5">IsVerbose</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if data dump mode is enabled.  <a href="#ec655def4d700239e60ed3ccb417e0c5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class RecordT&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceBarry.html#d9b9de17676484b0a956a2944602f84c">ParseDBData</a> (const <a class="el" href="classBarry_1_1DBData.html">DBData</a> &amp;data, RecordT &amp;rec, const <a class="el" href="classBarry_1_1IConverter.html">IConverter</a> *ic)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contains the proper way to convert a <a class="el" href="classBarry_1_1DBData.html" title="Database record data class.">DBData</a> object into a record.  <a href="#d9b9de17676484b0a956a2944602f84c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const TimeZone *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBarry.html#b664177c654a0cb41bc8fc40b39eabda">GetTimeZoneTable</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to an array of TimeZone structs.  <a href="#b664177c654a0cb41bc8fc40b39eabda"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const TimeZone *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBarry.html#8b42d46bf7b5cb8f4d9e0bde1d61f226">GetTimeZone</a> (unsigned short Code)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches the internal timezone code table for the given Code and returns a pointer to a TimeZone struct found.  <a href="#8b42d46bf7b5cb8f4d9e0bde1d61f226"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBarry.html#56ac220ad3edcfbefcebb35c685212d1">GetTimeZoneCode</a> (signed short HourOffset, signed short MinOffset)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches the internal timezone table for the first matching Code.  <a href="#56ac220ad3edcfbefcebb35c685212d1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">time_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBarry.html#30255c53ebed390fc98a50e9c5d49984">DayToDate</a> (unsigned short Day)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This routine takes the day of the year and returns a time_t adjusted from the first of the year.  <a href="#30255c53ebed390fc98a50e9c5d49984"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">time_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBarry.html#2f4e6ee9d4afc6a26ae0166329609600">Message2Time</a> (uint16_t r_date, uint16_t r_time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Localize the funky math used to convert a Blackberry message timestamp into a time_t.  <a href="#2f4e6ee9d4afc6a26ae0166329609600"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BXEXPORT struct timespec *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBarry.html#0e1dc80f82d25739631c39b545f812bb">ThreadTimeout</a> (int timeout_ms, struct timespec *spec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a pthread_cond_timedwait() compatible timespec struct, based on a given timeout in milliseconds.  <a href="#0e1dc80f82d25739631c39b545f812bb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBarry.html#06ec709ed2313dd84291b2d295a87d26">Version</a> (int &amp;major, int &amp;minor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fills major and minor with integer version numbers, and returns a string containing human readable version information in English.  <a href="#06ec709ed2313dd84291b2d295a87d26"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="30255c53ebed390fc98a50e9c5d49984"></a><!-- doxytag: member="Barry::DayToDate" ref="30255c53ebed390fc98a50e9c5d49984" args="(unsigned short Day)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BXEXPORT time_t Barry::DayToDate           </td>
          <td>(</td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>Day</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This routine takes the day of the year and returns a time_t adjusted from the first of the year. 
<p>
FIXME This function assumes the year hasn't changed, but I don't have enough information to determine where the year is in this header info 
<p>Definition at line <a class="el" href="time_8cc-source.html#l00186">186</a> of file <a class="el" href="time_8cc-source.html">time.cc</a>.</p>

<p>Referenced by <a class="el" href="time_8cc-source.html#l00217">Message2Time()</a>.</p>

<p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<p><center><img src="namespaceBarry_30255c53ebed390fc98a50e9c5d49984_icgraph.png" border="0" usemap="#namespaceBarry_30255c53ebed390fc98a50e9c5d49984_icgraph_map" alt=""></center>
<map name="namespaceBarry_30255c53ebed390fc98a50e9c5d49984_icgraph_map">
<area shape="rect" href="namespaceBarry.html#2f4e6ee9d4afc6a26ae0166329609600" title="Localize the funky math used to convert a Blackberry message timestamp into a time_t..." alt="" coords="179,5,328,32"></map>
</div>

</div>
</div><p>
<a class="anchor" name="8b42d46bf7b5cb8f4d9e0bde1d61f226"></a><!-- doxytag: member="Barry::GetTimeZone" ref="8b42d46bf7b5cb8f4d9e0bde1d61f226" args="(unsigned short Code)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BXEXPORT const TimeZone * Barry::GetTimeZone           </td>
          <td>(</td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>Code</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches the internal timezone code table for the given Code and returns a pointer to a TimeZone struct found. 
<p>
If the code is not found, a pointer to a valid TimeZone struct is is still returned, but the struct's Code contains TIME_ZONE_CODE_ERR, and the name is "Unknown time zone." The unknown timezone is the same offset as GMT. 
<p>Definition at line <a class="el" href="time_8cc-source.html#l00149">149</a> of file <a class="el" href="time_8cc-source.html">time.cc</a>.</p>

</div>
</div><p>
<a class="anchor" name="56ac220ad3edcfbefcebb35c685212d1"></a><!-- doxytag: member="Barry::GetTimeZoneCode" ref="56ac220ad3edcfbefcebb35c685212d1" args="(signed short HourOffset, signed short MinOffset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BXEXPORT unsigned short Barry::GetTimeZoneCode           </td>
          <td>(</td>
          <td class="paramtype">signed short&nbsp;</td>
          <td class="paramname"> <em>HourOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed short&nbsp;</td>
          <td class="paramname"> <em>MinOffset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches the internal timezone table for the first matching Code. 
<p>
If no matching Code is found, TIME_ZONE_CODE_ERR is returned.<p>
This function does not adjust for daylight saving time. 
<p>Definition at line <a class="el" href="time_8cc-source.html#l00168">168</a> of file <a class="el" href="time_8cc-source.html">time.cc</a>.</p>

</div>
</div><p>
<a class="anchor" name="b664177c654a0cb41bc8fc40b39eabda"></a><!-- doxytag: member="Barry::GetTimeZoneTable" ref="b664177c654a0cb41bc8fc40b39eabda" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BXEXPORT const TimeZone * Barry::GetTimeZoneTable           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a pointer to an array of TimeZone structs. 
<p>
The last struct contains 0 in all fields, and can be used as an "end of array" marker. 
<p>Definition at line <a class="el" href="time_8cc-source.html#l00134">134</a> of file <a class="el" href="time_8cc-source.html">time.cc</a>.</p>

</div>
</div><p>
<a class="anchor" name="e9d92a617771de40f7bb5a15b8da1807"></a><!-- doxytag: member="Barry::GetTotalBitmapSize" ref="e9d92a617771de40f7bb5a15b8da1807" args="(const JLScreenInfo &amp;info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BXEXPORT size_t Barry::GetTotalBitmapSize           </td>
          <td>(</td>
          <td class="paramtype">const JLScreenInfo &amp;&nbsp;</td>
          <td class="paramname"> <em>info</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the total number of bytes needed to convert a screenshot of the given dimensions into a bitmap, using the <a class="el" href="namespaceBarry.html#9da780aab46e04d16fddd855c85933ba" title="Converts screenshot data obtained via JavaLoader::GetScreenshot() into uncompressed...">ScreenshotToBitmap()</a> function. 
<p>

<p>Definition at line <a class="el" href="bmp_8cc-source.html#l00037">37</a> of file <a class="el" href="bmp_8cc-source.html">bmp.cc</a>.</p>

<p>Referenced by <a class="el" href="bmp_8cc-source.html#l00057">ScreenshotToBitmap()</a>.</p>

<p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<p><center><img src="namespaceBarry_e9d92a617771de40f7bb5a15b8da1807_icgraph.png" border="0" usemap="#namespaceBarry_e9d92a617771de40f7bb5a15b8da1807_icgraph_map" alt=""></center>
<map name="namespaceBarry_e9d92a617771de40f7bb5a15b8da1807_icgraph_map">
<area shape="rect" href="namespaceBarry.html#9da780aab46e04d16fddd855c85933ba" title="Converts screenshot data obtained via JavaLoader::GetScreenshot() into uncompressed..." alt="" coords="229,5,411,32"></map>
</div>

</div>
</div><p>
<a class="anchor" name="2e28bd59aebe0bece5a46f02ef7dbd3d"></a><!-- doxytag: member="Barry::Init" ref="2e28bd59aebe0bece5a46f02ef7dbd3d" args="(bool data_dump_mode, std::ostream *logStream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BXEXPORT void Barry::Init           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>data_dump_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&nbsp;</td>
          <td class="paramname"> <em>logStream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="namespaceBarry.html" title="Project namespace, containing all related functions and classes.">Barry</a> library initializer. 
<p>
See also the <a class="el" href="classBarry_1_1LogLock.html" title="RAII locking class used to protect the logStream passed into Barry::Init() (common...">LogLock</a> class.<p>
Call this before anything else. This takes care of initializing the lower level libusb.<p>
This function is safe to be called multiple times. The data_dump_mode and the log stream will be updated each time it is called, but the USB library will not be re-initialized.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data_dump_mode</em>&nbsp;</td><td>If set to true, the protocol conversation will be sent to the logStream specified in the second argument. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>LogStream</em>&nbsp;</td><td>Pointer to std::ostream object to use for debug output and logging. Defaults to std::cout. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="common_8cc-source.html#l00052">52</a> of file <a class="el" href="common_8cc-source.html">common.cc</a>.</p>

</div>
</div><p>
<a class="anchor" name="ec655def4d700239e60ed3ccb417e0c5"></a><!-- doxytag: member="Barry::IsVerbose" ref="ec655def4d700239e60ed3ccb417e0c5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BXEXPORT bool Barry::IsVerbose           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if data dump mode is enabled. 
<p>

<p>Definition at line <a class="el" href="common_8cc-source.html#l00105">105</a> of file <a class="el" href="common_8cc-source.html">common.cc</a>.</p>

</div>
</div><p>
<a class="anchor" name="2f4e6ee9d4afc6a26ae0166329609600"></a><!-- doxytag: member="Barry::Message2Time" ref="2f4e6ee9d4afc6a26ae0166329609600" args="(uint16_t r_date, uint16_t r_time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BXEXPORT time_t Barry::Message2Time           </td>
          <td>(</td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>r_date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>r_time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Localize the funky math used to convert a Blackberry message timestamp into a time_t. 
<p>
Both r_date and r_time are expected to be fed in from the Protocol::MessageRecord struct in raw form, without endian conversion. This function handles that. 
<p>Definition at line <a class="el" href="time_8cc-source.html#l00217">217</a> of file <a class="el" href="time_8cc-source.html">time.cc</a>.</p>

<p>References <a class="el" href="time_8cc-source.html#l00186">DayToDate()</a>.</p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<p><center><img src="namespaceBarry_2f4e6ee9d4afc6a26ae0166329609600_cgraph.png" border="0" usemap="#namespaceBarry_2f4e6ee9d4afc6a26ae0166329609600_cgraph_map" alt=""></center>
<map name="namespaceBarry_2f4e6ee9d4afc6a26ae0166329609600_cgraph_map">
<area shape="rect" href="namespaceBarry.html#30255c53ebed390fc98a50e9c5d49984" title="This routine takes the day of the year and returns a time_t adjusted from the first..." alt="" coords="204,5,327,32"></map>
</div>

</div>
</div><p>
<a class="anchor" name="d9b9de17676484b0a956a2944602f84c"></a><!-- doxytag: member="Barry::ParseDBData" ref="d9b9de17676484b0a956a2944602f84c" args="(const DBData &amp;data, RecordT &amp;rec, const IConverter *ic)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RecordT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Barry::ParseDBData           </td>
          <td>(</td>
          <td class="paramtype">const DBData &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RecordT &amp;&nbsp;</td>
          <td class="paramname"> <em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IConverter *&nbsp;</td>
          <td class="paramname"> <em>ic</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Contains the proper way to convert a <a class="el" href="classBarry_1_1DBData.html" title="Database record data class.">DBData</a> object into a record. 
<p>

<p>Definition at line <a class="el" href="parser_8h-source.html#l00221">221</a> of file <a class="el" href="parser_8h-source.html">parser.h</a>.</p>

<p>References <a class="el" href="data_8h-source.html#l00208">Barry::DBData::GetData()</a>, <a class="el" href="data_8h-source.html#l00206">Barry::DBData::GetOffset()</a>, <a class="el" href="data_8h-source.html#l00204">Barry::DBData::GetRecType()</a>, and <a class="el" href="data_8h-source.html#l00205">Barry::DBData::GetUniqueId()</a>.</p>

<p>Referenced by <a class="el" href="parser_8h-source.html#l00310">Barry::RecordParser&lt; RecordT, StorageT &gt;::ParseRecord()</a>.</p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<p><center><img src="namespaceBarry_d9b9de17676484b0a956a2944602f84c_cgraph.png" border="0" usemap="#namespaceBarry_d9b9de17676484b0a956a2944602f84c_cgraph_map" alt=""></center>
<map name="namespaceBarry_d9b9de17676484b0a956a2944602f84c_cgraph_map">
<area shape="rect" href="classBarry_1_1DBData.html#a7cacc9655376447ffbf3aa4d664a03b" title="Barry::DBData::GetData" alt="" coords="208,5,368,32"><area shape="rect" href="classBarry_1_1DBData.html#5b301bfdcda5a74ccfd3f7e54fd69d99" title="Barry::DBData::GetOffset" alt="" coords="204,56,372,83"><area shape="rect" href="classBarry_1_1DBData.html#07523eb3b1dcfd99a917a184b61cb10a" title="Barry::DBData::GetRecType" alt="" coords="196,107,380,133"><area shape="rect" href="classBarry_1_1DBData.html#2a0106c7330842c455fc5393a3abfbc7" title="Barry::DBData::GetUniqueId" alt="" coords="196,157,380,184"></map>
</div>

<p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<p><center><img src="namespaceBarry_d9b9de17676484b0a956a2944602f84c_icgraph.png" border="0" usemap="#namespaceBarry_d9b9de17676484b0a956a2944602f84c_icgraph_map" alt=""></center>
<map name="namespaceBarry_d9b9de17676484b0a956a2944602f84c_icgraph_map">
<area shape="rect" href="classBarry_1_1RecordParser.html#83fe40db19e22eeb7ac94d8385650b75" title="Called to parse sub fields in the raw data packet." alt="" coords="196,5,417,32"></map>
</div>

</div>
</div><p>
<a class="anchor" name="9da780aab46e04d16fddd855c85933ba"></a><!-- doxytag: member="Barry::ScreenshotToBitmap" ref="9da780aab46e04d16fddd855c85933ba" args="(const JLScreenInfo &amp;info, const Data &amp;screenshot, Data &amp;bitmap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BXEXPORT void Barry::ScreenshotToBitmap           </td>
          <td>(</td>
          <td class="paramtype">const JLScreenInfo &amp;&nbsp;</td>
          <td class="paramname"> <em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Data &amp;&nbsp;</td>
          <td class="paramname"> <em>screenshot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Data &amp;&nbsp;</td>
          <td class="paramname"> <em>bitmap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts screenshot data obtained via JavaLoader::GetScreenshot() into uncompressed bitmap format, suitable for writing BMP files. 
<p>
Arguments info and screenshot come from GetScreenshot() and the converted data is stored in bitmap. 
<p>Definition at line <a class="el" href="bmp_8cc-source.html#l00057">57</a> of file <a class="el" href="bmp_8cc-source.html">bmp.cc</a>.</p>

<p>References <a class="el" href="bmp_8cc-source.html#l00037">GetTotalBitmapSize()</a>.</p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<p><center><img src="namespaceBarry_9da780aab46e04d16fddd855c85933ba_cgraph.png" border="0" usemap="#namespaceBarry_9da780aab46e04d16fddd855c85933ba_cgraph_map" alt=""></center>
<map name="namespaceBarry_9da780aab46e04d16fddd855c85933ba_cgraph_map">
<area shape="rect" href="namespaceBarry.html#e9d92a617771de40f7bb5a15b8da1807" title="Returns the total number of bytes needed to convert a screenshot of the given dimensions..." alt="" coords="235,5,411,32"></map>
</div>

</div>
</div><p>
<a class="anchor" name="07808b7a4cabe1399d5432eb1ee1eabf"></a><!-- doxytag: member="Barry::SeekNextCod" ref="07808b7a4cabe1399d5432eb1ee1eabf" args="(std::istream &amp;input)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Barry::SeekNextCod           </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>input</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Seeks the input stream to the next packed sibling .cod file and returns the packed .cod file size. 
<p>
When all siblings have been read, zero is returned.<p>
When input stream does not contain the signature for a packed .cod file, it's assumed the entire stream is the .cod file.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>input</em>&nbsp;</td><td>stream to read from</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>size of next packed .cod file, or 0 finished reading .cod files </dd></dl>

<p>Definition at line <a class="el" href="cod_8cc-source.html#l00044">44</a> of file <a class="el" href="cod_8cc-source.html">cod.cc</a>.</p>

</div>
</div><p>
<a class="anchor" name="1694e381d8f7c0a41714992c831e716b"></a><!-- doxytag: member="Barry::SetDBData" ref="1694e381d8f7c0a41714992c831e716b" args="(const RecordT &amp;rec, DBData &amp;data, size_t &amp;offset, const IConverter *ic)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RecordT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Barry::SetDBData           </td>
          <td>(</td>
          <td class="paramtype">const RecordT &amp;&nbsp;</td>
          <td class="paramname"> <em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DBData &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IConverter *&nbsp;</td>
          <td class="paramname"> <em>ic</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Contains the proper way to convert a record object into a <a class="el" href="classBarry_1_1DBData.html" title="Database record data class.">DBData</a> object. 
<p>

<p>Definition at line <a class="el" href="builder_8h-source.html#l00135">135</a> of file <a class="el" href="builder_8h-source.html">builder.h</a>.</p>

<p>References <a class="el" href="data_8h-source.html#l00217">Barry::DBData::SetDBName()</a>, <a class="el" href="data_8h-source.html#l00222">Barry::DBData::SetIds()</a>, <a class="el" href="data_8h-source.html#l00228">Barry::DBData::SetOffset()</a>, <a class="el" href="data_8h-source.html#l00212">Barry::DBData::SetVersion()</a>, and <a class="el" href="data_8cc-source.html#l00467">Barry::DBData::UseData()</a>.</p>

<p>Referenced by <a class="el" href="builder_8h-source.html#l00203">Barry::RecordBuilder&lt; RecordT, StorageT &gt;::BuildRecord()</a>.</p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<p><center><img src="namespaceBarry_1694e381d8f7c0a41714992c831e716b_cgraph.png" border="0" usemap="#namespaceBarry_1694e381d8f7c0a41714992c831e716b_cgraph_map" alt=""></center>
<map name="namespaceBarry_1694e381d8f7c0a41714992c831e716b_cgraph_map">
<area shape="rect" href="classBarry_1_1DBData.html#55d6bde680fe0b48d07882ade96ef9c3" title="Barry::DBData::SetDBName" alt="" coords="180,5,364,32"><area shape="rect" href="classBarry_1_1DBData.html#a46147fced1b122cb6a0e6d1cee3cb07" title="Barry::DBData::SetIds" alt="" coords="196,56,348,83"><area shape="rect" href="classBarry_1_1DBData.html#cb569139ee2d44442d4709ccf2a4ab3c" title="Barry::DBData::SetOffset" alt="" coords="188,107,356,133"><area shape="rect" href="classBarry_1_1DBData.html#d1a3e69cabea68e0a309459cd7c58e78" title="Barry::DBData::SetVersion" alt="" coords="184,157,360,184"><area shape="rect" href="classBarry_1_1DBData.html#3c1c4ad5ce85cef0ea85002a0fe07881" title="Barry::DBData::UseData" alt="" coords="191,208,353,235"></map>
</div>

<p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<p><center><img src="namespaceBarry_1694e381d8f7c0a41714992c831e716b_icgraph.png" border="0" usemap="#namespaceBarry_1694e381d8f7c0a41714992c831e716b_icgraph_map" alt=""></center>
<map name="namespaceBarry_1694e381d8f7c0a41714992c831e716b_icgraph_map">
<area shape="rect" href="classBarry_1_1RecordBuilder.html#cc484ee4a8e30cf634e86c282498e9a0" title="Called to build the record field data." alt="" coords="180,5,399,32"><area shape="rect" href="classBarry_1_1RecordBuilder.html#12bf6698689b031986008924d8c66946" title="Same as BuildRecord, but does not care about any offsets." alt="" coords="448,5,672,32"></map>
</div>

</div>
</div><p>
<a class="anchor" name="0e1dc80f82d25739631c39b545f812bb"></a><!-- doxytag: member="Barry::ThreadTimeout" ref="0e1dc80f82d25739631c39b545f812bb" args="(int timeout_ms, struct timespec *spec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BXEXPORT struct timespec * Barry::ThreadTimeout           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *&nbsp;</td>
          <td class="paramname"> <em>spec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a pthread_cond_timedwait() compatible timespec struct, based on a given timeout in milliseconds. 
<p>
Note that the resulting timespec is time-sensitive: the 'timer' starts as soon as this function returns, since timespec is a specific time in the future, and <a class="el" href="namespaceBarry.html#0e1dc80f82d25739631c39b545f812bb" title="Creates a pthread_cond_timedwait() compatible timespec struct, based on a given timeout...">ThreadTimeout()</a> calculates it based on the current time.<p>
Returns the spec pointer, to make it easy to use with pthread_cond_timedwait() 
<p>Definition at line <a class="el" href="time_8cc-source.html#l00242">242</a> of file <a class="el" href="time_8cc-source.html">time.cc</a>.</p>

<p>Referenced by <a class="el" href="dataqueue_8cc-source.html#l00108">Barry::DataQueue::wait_pop()</a>.</p>

<p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<p><center><img src="namespaceBarry_0e1dc80f82d25739631c39b545f812bb_icgraph.png" border="0" usemap="#namespaceBarry_0e1dc80f82d25739631c39b545f812bb_icgraph_map" alt=""></center>
<map name="namespaceBarry_0e1dc80f82d25739631c39b545f812bb_icgraph_map">
<area shape="rect" href="classBarry_1_1DataQueue.html#27d4830d37b0f7a1bee3a63b0f5a5b2b" title="Pops the next element off the front of the queue, and waits until one exists if empty..." alt="" coords="203,5,387,32"></map>
</div>

</div>
</div><p>
<a class="anchor" name="59da38213acb8827d30bddfc54bbfe2a"></a><!-- doxytag: member="Barry::Verbose" ref="59da38213acb8827d30bddfc54bbfe2a" args="(bool data_dump_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BXEXPORT void Barry::Verbose           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>data_dump_mode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This API call lets the application enable / disable verbose debug output on the fly. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data_dump_mode</em>&nbsp;</td><td>If set to true, the protocol conversation will be sent to the logStream specified in the <a class="el" href="namespaceBarry.html#2e28bd59aebe0bece5a46f02ef7dbd3d" title="Barry library initializer.">Barry::Init()</a> call. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="common_8cc-source.html#l00090">90</a> of file <a class="el" href="common_8cc-source.html">common.cc</a>.</p>

</div>
</div><p>
<a class="anchor" name="06ec709ed2313dd84291b2d295a87d26"></a><!-- doxytag: member="Barry::Version" ref="06ec709ed2313dd84291b2d295a87d26" args="(int &amp;major, int &amp;minor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BXEXPORT const char * Barry::Version           </td>
          <td>(</td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>major</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>minor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fills major and minor with integer version numbers, and returns a string containing human readable version information in English. 
<p>

<p>Definition at line <a class="el" href="version_8cc-source.html#l00039">39</a> of file <a class="el" href="version_8cc-source.html">version.cc</a>.</p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Feb 10 16:14:35 2011 for Barry by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
