<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Barry: Barry::Restore Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceBarry.html">Barry</a>::<a class="el" href="classBarry_1_1Restore.html">Restore</a>
  </div>
</div>
<div class="contents">
<h1>Barry::Restore Class Reference</h1><!-- doxytag: class="Barry::Restore" --><!-- doxytag: inherits="Barry::Builder" --><code>#include &lt;<a class="el" href="restore_8h-source.html">restore.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for Barry::Restore:</div>
<div class="dynsection">
<p><center><img src="classBarry_1_1Restore__inherit__graph.png" border="0" usemap="#Barry_1_1Restore__inherit__map" alt="Inheritance graph"></center>
<map name="Barry_1_1Restore__inherit__map">
<area shape="rect" href="classBarry_1_1Builder.html" title="Base class for the builder functor hierarchy." alt="" coords="8,5,107,32"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>
<div class="dynheader">
Collaboration diagram for Barry::Restore:</div>
<div class="dynsection">
<p><center><img src="classBarry_1_1Restore__coll__graph.png" border="0" usemap="#Barry_1_1Restore__coll__map" alt="Collaboration graph"></center>
<map name="Barry_1_1Restore__coll__map">
<area shape="rect" href="classBarry_1_1Builder.html" title="Base class for the builder functor hierarchy." alt="" coords="799,5,897,32"><area shape="rect" title="STL class." alt="" coords="424,89,589,116"><area shape="rect" title="STL class." alt="" coords="224,183,304,209"><area shape="rect" title="STL class." alt="" coords="7,183,172,209"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classBarry_1_1Restore-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
<a class="el" href="namespaceBarry.html" title="Project namespace, containing all related functions and classes.">Barry</a> Backup <a class="el" href="classBarry_1_1Restore.html" title="Barry Backup Restore builder class.">Restore</a> builder class. 
<p>
This class is suitable to be used as a builder object anywhere a builder object is accepted. It reads from a <a class="el" href="namespaceBarry.html" title="Project namespace, containing all related functions and classes.">Barry</a> Backup tar.gz backup file, and builds records in a staged manner.<p>
If a backup file contains more than one database (for example both Address Book and Calendar), then it will build one database first, return false on Retrieve(), and then build the next. If Retrieve() returns false, but <a class="el" href="classBarry_1_1Restore.html#4d8f64fce3b905a756185e1a9ca0c09e" title="Sometimes a builder can have multiple databases stored in it, so when Build/Fetch...">EndOfFile()</a> also returns false, then more databases are available.<p>
The idea is that you can call Desktop::SaveDatabase() multiple times with this same <a class="el" href="classBarry_1_1Restore.html" title="Barry Backup Restore builder class.">Restore</a> object, for all the databases in the backup file.<p>
It is safe to call Retrieve() multiple times, so when first starting a restore:<ul>
<li>call the constructor</li><li>call <a class="el" href="classBarry_1_1Restore.html#e8d23b32bbbb26d4bd02961cd9b32262" title="Add database name to the read filter.">AddDB()</a> with any filters</li><li>then call Retrieve(), which will grab the first record, and make GetDBName() valid. </li></ul>

<p>Definition at line <a class="el" href="restore_8h-source.html#l00064">64</a> of file <a class="el" href="restore_8h-source.html">restore.h</a>.</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1Restore.html#d23e005d6fadc20cde4c6f12e2bfa892">Restore</a> (const std::string &amp;tarpath, bool default_all_db=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If default_all_db is true, and none of the Add*() functions are called (meaning that <a class="el" href="classBarry_1_1Restore.html" title="Barry Backup Restore builder class.">Restore</a> has an empty database list), then all records are restored.  <a href="#d23e005d6fadc20cde4c6f12e2bfa892"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1Restore.html#e8d23b32bbbb26d4bd02961cd9b32262">AddDB</a> (const std::string &amp;dbName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add database name to the read filter.  <a href="#e8d23b32bbbb26d4bd02961cd9b32262"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1Restore.html#210fba48d39754019bbbb893e404a849">Add</a> (const DBListType &amp;dbList)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add all database names in dblist to the read filter This function is additive.  <a href="#210fba48d39754019bbbb893e404a849"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1Restore.html#97e837397dbfe9e027bd5745a42011d5">GetRecordTotal</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Loads the given file, and counts all records according to the current read filter.  <a href="#97e837397dbfe9e027bd5745a42011d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1Restore.html#ca46f9c51a68eb3872f98a73bdcd226c">GetNextMeta</a> (<a class="el" href="classBarry_1_1DBData.html">DBData</a> &amp;data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If this function returns true, it fills data with the meta data that the next call to <a class="el" href="classBarry_1_1Restore.html#59f9e2d2e9dd3d7c40588416b27b5ee7" title="Called to build the record field data.">BuildRecord()</a> will retrieve.  <a href="#ca46f9c51a68eb3872f98a73bdcd226c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1Restore.html#59f9e2d2e9dd3d7c40588416b27b5ee7">BuildRecord</a> (<a class="el" href="classBarry_1_1DBData.html">Barry::DBData</a> &amp;data, size_t &amp;offset, const <a class="el" href="classBarry_1_1IConverter.html">Barry::IConverter</a> *ic)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called to build the record field data.  <a href="#59f9e2d2e9dd3d7c40588416b27b5ee7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1Restore.html#fc3e4162a0ae1c19d338126d920abb57">FetchRecord</a> (<a class="el" href="classBarry_1_1DBData.html">Barry::DBData</a> &amp;data, const <a class="el" href="classBarry_1_1IConverter.html">Barry::IConverter</a> *ic)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as BuildRecord, but does not care about any offsets.  <a href="#fc3e4162a0ae1c19d338126d920abb57"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1Restore.html#4d8f64fce3b905a756185e1a9ca0c09e">EndOfFile</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sometimes a builder can have multiple databases stored in it, so when Build/Fetch returns false, check if there is more data with this function.  <a href="#4d8f64fce3b905a756185e1a9ca0c09e"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1Restore.html#2c57a7bbe16c2c37ff38ccb6f3d42a39">GetRecordTotal</a> (const std::string &amp;tarpath, const DBListType &amp;dbList, bool default_all_db)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Static version of above call.  <a href="#2c57a7bbe16c2c37ff38ccb6f3d42a39"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBarry_1_1Restore.html#eed51b73f7d5125ae655af0a965a8113">SplitTarPath</a> (const std::string &amp;tarpath, std::string &amp;dbname, std::string &amp;dbid_text, uint8_t &amp;dbrectype, uint32_t &amp;dbid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Splits a tarpath of the form "DBName/DBID" into separate string values.  <a href="#eed51b73f7d5125ae655af0a965a8113"></a><br></td></tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="d23e005d6fadc20cde4c6f12e2bfa892"></a><!-- doxytag: member="Barry::Restore::Restore" ref="d23e005d6fadc20cde4c6f12e2bfa892" args="(const std::string &amp;tarpath, bool default_all_db=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Barry::Restore::Restore           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>tarpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>default_all_db</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If default_all_db is true, and none of the Add*() functions are called (meaning that <a class="el" href="classBarry_1_1Restore.html" title="Barry Backup Restore builder class.">Restore</a> has an empty database list), then all records are restored. 
<p>
If false in this situation, nothing is restored.<p>
If any of the Add*() functions are called, then the database list takes precedence, and default_all_db has no effect. 
<p>Definition at line <a class="el" href="restore_8cc-source.html#l00096">96</a> of file <a class="el" href="restore_8cc-source.html">restore.cc</a>.</p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="eed51b73f7d5125ae655af0a965a8113"></a><!-- doxytag: member="Barry::Restore::SplitTarPath" ref="eed51b73f7d5125ae655af0a965a8113" args="(const std::string &amp;tarpath, std::string &amp;dbname, std::string &amp;dbid_text, uint8_t &amp;dbrectype, uint32_t &amp;dbid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Barry::Restore::SplitTarPath           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>tarpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>dbname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>dbid_text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t &amp;&nbsp;</td>
          <td class="paramname"> <em>dbrectype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&nbsp;</td>
          <td class="paramname"> <em>dbid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Splits a tarpath of the form "DBName/DBID" into separate string values. 
<p>
Returns true if successful, false if tarpath is a bad name. 
<p>Definition at line <a class="el" href="restore_8cc-source.html#l00069">69</a> of file <a class="el" href="restore_8cc-source.html">restore.cc</a>.</p>

</div>
</div><p>
<a class="anchor" name="e8d23b32bbbb26d4bd02961cd9b32262"></a><!-- doxytag: member="Barry::Restore::AddDB" ref="e8d23b32bbbb26d4bd02961cd9b32262" args="(const std::string &amp;dbName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Barry::Restore::AddDB           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>dbName</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add database name to the read filter. 
<p>

<p>Definition at line <a class="el" href="restore_8cc-source.html#l00133">133</a> of file <a class="el" href="restore_8cc-source.html">restore.cc</a>.</p>

<p>Referenced by <a class="el" href="restore_8cc-source.html#l00141">Add()</a>.</p>

<p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<p><center><img src="classBarry_1_1Restore_e8d23b32bbbb26d4bd02961cd9b32262_icgraph.png" border="0" usemap="#classBarry_1_1Restore_e8d23b32bbbb26d4bd02961cd9b32262_icgraph_map" alt=""></center>
<map name="classBarry_1_1Restore_e8d23b32bbbb26d4bd02961cd9b32262_icgraph_map">
<area shape="rect" href="classBarry_1_1Restore.html#210fba48d39754019bbbb893e404a849" title="Add all database names in dblist to the read filter This function is additive." alt="" coords="208,5,344,32"></map>
</div>

</div>
</div><p>
<a class="anchor" name="210fba48d39754019bbbb893e404a849"></a><!-- doxytag: member="Barry::Restore::Add" ref="210fba48d39754019bbbb893e404a849" args="(const DBListType &amp;dbList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Barry::Restore::Add           </td>
          <td>(</td>
          <td class="paramtype">const DBListType &amp;&nbsp;</td>
          <td class="paramname"> <em>dbList</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add all database names in dblist to the read filter This function is additive. 
<p>

<p>Definition at line <a class="el" href="restore_8cc-source.html#l00141">141</a> of file <a class="el" href="restore_8cc-source.html">restore.cc</a>.</p>

<p>References <a class="el" href="restore_8cc-source.html#l00133">AddDB()</a>.</p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<p><center><img src="classBarry_1_1Restore_210fba48d39754019bbbb893e404a849_cgraph.png" border="0" usemap="#classBarry_1_1Restore_210fba48d39754019bbbb893e404a849_cgraph_map" alt=""></center>
<map name="classBarry_1_1Restore_210fba48d39754019bbbb893e404a849_cgraph_map">
<area shape="rect" href="classBarry_1_1Restore.html#e8d23b32bbbb26d4bd02961cd9b32262" title="Add database name to the read filter." alt="" coords="189,5,344,32"></map>
</div>

</div>
</div><p>
<a class="anchor" name="97e837397dbfe9e027bd5745a42011d5"></a><!-- doxytag: member="Barry::Restore::GetRecordTotal" ref="97e837397dbfe9e027bd5745a42011d5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Barry::Restore::GetRecordTotal           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Loads the given file, and counts all records according to the current read filter. 
<p>
Does not use the main <a class="el" href="classBarry_1_1Restore.html" title="Barry Backup Restore builder class.">Restore</a> file, but opens the file separately. It is safe to call this function as often as needed. 
<p>Definition at line <a class="el" href="restore_8cc-source.html#l00167">167</a> of file <a class="el" href="restore_8cc-source.html">restore.cc</a>.</p>

</div>
</div><p>
<a class="anchor" name="2c57a7bbe16c2c37ff38ccb6f3d42a39"></a><!-- doxytag: member="Barry::Restore::GetRecordTotal" ref="2c57a7bbe16c2c37ff38ccb6f3d42a39" args="(const std::string &amp;tarpath, const DBListType &amp;dbList, bool default_all_db)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Barry::Restore::GetRecordTotal           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>tarpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DBListType &amp;&nbsp;</td>
          <td class="paramname"> <em>dbList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>default_all_db</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Static version of above call. 
<p>

<p>Definition at line <a class="el" href="restore_8cc-source.html#l00172">172</a> of file <a class="el" href="restore_8cc-source.html">restore.cc</a>.</p>

</div>
</div><p>
<a class="anchor" name="ca46f9c51a68eb3872f98a73bdcd226c"></a><!-- doxytag: member="Barry::Restore::GetNextMeta" ref="ca46f9c51a68eb3872f98a73bdcd226c" args="(DBData &amp;data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Barry::Restore::GetNextMeta           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBarry_1_1DBData.html">DBData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If this function returns true, it fills data with the meta data that the next call to <a class="el" href="classBarry_1_1Restore.html#59f9e2d2e9dd3d7c40588416b27b5ee7" title="Called to build the record field data.">BuildRecord()</a> will retrieve. 
<p>
This is useful for applications that need to setup a manual call to Desktop::SaveDatabase(). 
<p>Definition at line <a class="el" href="restore_8cc-source.html#l00192">192</a> of file <a class="el" href="restore_8cc-source.html">restore.cc</a>.</p>

<p>References <a class="el" href="data_8h-source.html#l00217">Barry::DBData::SetDBName()</a>, <a class="el" href="data_8h-source.html#l00222">Barry::DBData::SetIds()</a>, <a class="el" href="data_8h-source.html#l00228">Barry::DBData::SetOffset()</a>, and <a class="el" href="data_8h-source.html#l00212">Barry::DBData::SetVersion()</a>.</p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<p><center><img src="classBarry_1_1Restore_ca46f9c51a68eb3872f98a73bdcd226c_cgraph.png" border="0" usemap="#classBarry_1_1Restore_ca46f9c51a68eb3872f98a73bdcd226c_cgraph_map" alt=""></center>
<map name="classBarry_1_1Restore_ca46f9c51a68eb3872f98a73bdcd226c_cgraph_map">
<area shape="rect" href="classBarry_1_1DBData.html#55d6bde680fe0b48d07882ade96ef9c3" title="Barry::DBData::SetDBName" alt="" coords="247,5,431,32"><area shape="rect" href="classBarry_1_1DBData.html#a46147fced1b122cb6a0e6d1cee3cb07" title="Barry::DBData::SetIds" alt="" coords="263,56,415,83"><area shape="rect" href="classBarry_1_1DBData.html#cb569139ee2d44442d4709ccf2a4ab3c" title="Barry::DBData::SetOffset" alt="" coords="255,107,423,133"><area shape="rect" href="classBarry_1_1DBData.html#d1a3e69cabea68e0a309459cd7c58e78" title="Barry::DBData::SetVersion" alt="" coords="251,157,427,184"></map>
</div>

</div>
</div><p>
<a class="anchor" name="59f9e2d2e9dd3d7c40588416b27b5ee7"></a><!-- doxytag: member="Barry::Restore::BuildRecord" ref="59f9e2d2e9dd3d7c40588416b27b5ee7" args="(Barry::DBData &amp;data, size_t &amp;offset, const Barry::IConverter *ic)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Barry::Restore::BuildRecord           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBarry_1_1DBData.html">Barry::DBData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBarry_1_1IConverter.html">Barry::IConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>ic</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called to build the record field data. 
<p>
Store the raw data in data, using offset to know where to write. Be sure to update offset, and be sure to adjust the size of the data packet (possibly with Data::ReleaseBuffer()).<p>
Returns true if successful, and false if at the end of the series. Note that if <a class="el" href="classBarry_1_1Restore.html#4d8f64fce3b905a756185e1a9ca0c09e" title="Sometimes a builder can have multiple databases stored in it, so when Build/Fetch...">EndOfFile()</a> is false after this function returns false, then there may be another series available, which the next call to <a class="el" href="classBarry_1_1Restore.html#59f9e2d2e9dd3d7c40588416b27b5ee7" title="Called to build the record field data.">BuildRecord()</a> will determine. 
<p>Implements <a class="el" href="classBarry_1_1Builder.html#4a3d38061d957eb6dd0539b18d40e6ad">Barry::Builder</a>.</p>

<p>Definition at line <a class="el" href="restore_8cc-source.html#l00273">273</a> of file <a class="el" href="restore_8cc-source.html">restore.cc</a>.</p>

<p>References <a class="el" href="data_8h-source.html#l00217">Barry::DBData::SetDBName()</a>, <a class="el" href="data_8h-source.html#l00222">Barry::DBData::SetIds()</a>, <a class="el" href="data_8h-source.html#l00228">Barry::DBData::SetOffset()</a>, <a class="el" href="data_8h-source.html#l00212">Barry::DBData::SetVersion()</a>, and <a class="el" href="data_8cc-source.html#l00467">Barry::DBData::UseData()</a>.</p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<p><center><img src="classBarry_1_1Restore_59f9e2d2e9dd3d7c40588416b27b5ee7_cgraph.png" border="0" usemap="#classBarry_1_1Restore_59f9e2d2e9dd3d7c40588416b27b5ee7_cgraph_map" alt=""></center>
<map name="classBarry_1_1Restore_59f9e2d2e9dd3d7c40588416b27b5ee7_cgraph_map">
<area shape="rect" href="classBarry_1_1DBData.html#55d6bde680fe0b48d07882ade96ef9c3" title="Barry::DBData::SetDBName" alt="" coords="239,5,423,32"><area shape="rect" href="classBarry_1_1DBData.html#a46147fced1b122cb6a0e6d1cee3cb07" title="Barry::DBData::SetIds" alt="" coords="255,56,407,83"><area shape="rect" href="classBarry_1_1DBData.html#cb569139ee2d44442d4709ccf2a4ab3c" title="Barry::DBData::SetOffset" alt="" coords="247,107,415,133"><area shape="rect" href="classBarry_1_1DBData.html#d1a3e69cabea68e0a309459cd7c58e78" title="Barry::DBData::SetVersion" alt="" coords="243,157,419,184"><area shape="rect" href="classBarry_1_1DBData.html#3c1c4ad5ce85cef0ea85002a0fe07881" title="Barry::DBData::UseData" alt="" coords="249,208,412,235"></map>
</div>

</div>
</div><p>
<a class="anchor" name="fc3e4162a0ae1c19d338126d920abb57"></a><!-- doxytag: member="Barry::Restore::FetchRecord" ref="fc3e4162a0ae1c19d338126d920abb57" args="(Barry::DBData &amp;data, const Barry::IConverter *ic)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Barry::Restore::FetchRecord           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBarry_1_1DBData.html">Barry::DBData</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBarry_1_1IConverter.html">Barry::IConverter</a> *&nbsp;</td>
          <td class="paramname"> <em>ic</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as BuildRecord, but does not care about any offsets. 
<p>
The caller should call DBData::GetOffset() afterward to discover if there is an offset to the result.<p>
This is usually the fastest of the two functions, since extra copying may be required if a specific offset is given. When building records from Record classes, both functions are the same speed. But when building records from the device, the device decides the offset, so <a class="el" href="classBarry_1_1Restore.html#fc3e4162a0ae1c19d338126d920abb57" title="Same as BuildRecord, but does not care about any offsets.">FetchRecord()</a> is faster, since BuildRecord requires a copy to adjust to the right offset.<p>
The caller should use the function that results in the least amount of copying for the caller. If the caller doesn't care about where the resulting record is in data, use <a class="el" href="classBarry_1_1Restore.html#fc3e4162a0ae1c19d338126d920abb57" title="Same as BuildRecord, but does not care about any offsets.">FetchRecord()</a>. 
<p>Implements <a class="el" href="classBarry_1_1Builder.html#005a0269c1f96947d7a75c1cc09a4609">Barry::Builder</a>.</p>

<p>Definition at line <a class="el" href="restore_8cc-source.html#l00316">316</a> of file <a class="el" href="restore_8cc-source.html">restore.cc</a>.</p>

<p>References <a class="el" href="data_8h-source.html#l00208">Barry::DBData::GetData()</a>, <a class="el" href="data_8h-source.html#l00217">Barry::DBData::SetDBName()</a>, <a class="el" href="data_8h-source.html#l00222">Barry::DBData::SetIds()</a>, <a class="el" href="data_8h-source.html#l00228">Barry::DBData::SetOffset()</a>, <a class="el" href="data_8h-source.html#l00212">Barry::DBData::SetVersion()</a>, and <a class="el" href="data_8cc-source.html#l00467">Barry::DBData::UseData()</a>.</p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<p><center><img src="classBarry_1_1Restore_fc3e4162a0ae1c19d338126d920abb57_cgraph.png" border="0" usemap="#classBarry_1_1Restore_fc3e4162a0ae1c19d338126d920abb57_cgraph_map" alt=""></center>
<map name="classBarry_1_1Restore_fc3e4162a0ae1c19d338126d920abb57_cgraph_map">
<area shape="rect" href="classBarry_1_1DBData.html#a7cacc9655376447ffbf3aa4d664a03b" title="Barry::DBData::GetData" alt="" coords="256,5,416,32"><area shape="rect" href="classBarry_1_1DBData.html#55d6bde680fe0b48d07882ade96ef9c3" title="Barry::DBData::SetDBName" alt="" coords="244,56,428,83"><area shape="rect" href="classBarry_1_1DBData.html#a46147fced1b122cb6a0e6d1cee3cb07" title="Barry::DBData::SetIds" alt="" coords="260,107,412,133"><area shape="rect" href="classBarry_1_1DBData.html#cb569139ee2d44442d4709ccf2a4ab3c" title="Barry::DBData::SetOffset" alt="" coords="252,157,420,184"><area shape="rect" href="classBarry_1_1DBData.html#d1a3e69cabea68e0a309459cd7c58e78" title="Barry::DBData::SetVersion" alt="" coords="248,208,424,235"><area shape="rect" href="classBarry_1_1DBData.html#3c1c4ad5ce85cef0ea85002a0fe07881" title="Barry::DBData::UseData" alt="" coords="255,259,417,285"></map>
</div>

</div>
</div><p>
<a class="anchor" name="4d8f64fce3b905a756185e1a9ca0c09e"></a><!-- doxytag: member="Barry::Restore::EndOfFile" ref="4d8f64fce3b905a756185e1a9ca0c09e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Barry::Restore::EndOfFile           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sometimes a builder can have multiple databases stored in it, so when Build/Fetch returns false, check if there is more data with this function. 
<p>
This function is not used by database-oriented functions, but by pipe- oriented functions. 
<p>Implements <a class="el" href="classBarry_1_1Builder.html#0ecfa5788ddee814a2071c82c5734691">Barry::Builder</a>.</p>

<p>Definition at line <a class="el" href="restore_8cc-source.html#l00368">368</a> of file <a class="el" href="restore_8cc-source.html">restore.cc</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="restore_8h-source.html">restore.h</a><li><a class="el" href="restore_8cc-source.html">restore.cc</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Feb 10 16:14:44 2011 for Barry by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
